name: AI Code Review (Latest Commit Only)

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to review'
        required: true
        type: number

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    env:
      LLM_API_BASE: https://api.openai.com/v1
      LLM_MODEL: gpt-5
      MAX_CHUNK_BYTES: "60000"

    steps:
      - name: Resolve PR number
        id: prnum
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "num=${{ inputs.pr_number }}" >> $GITHUB_OUTPUT
          else
            echo "num=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          fi

      - name: Checkout PR HEAD commit (not merge)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # Only set ref when event has pull_request context
          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || '' }}

      - name: Ensure we have PR metadata
        id: meta
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR=${{ steps.prnum.outputs.num }}
          gh pr view "$PR" --json title,body,headRefName,baseRefName,author,headRefOid > pr.json

      - name: Compute latest-commit diff (HEAD^..HEAD)
        id: diff
        run: |
          # Determine HEAD (for workflow_dispatch we need to check out the PR head explicitly)
          if [ -s pr.json ]; then
            HEAD_SHA=$(jq -r .headRefOid pr.json)
          else
            HEAD_SHA=$(git rev-parse HEAD)
          fi

          # Make sure HEAD_SHA exists locally (checkout step should have it)
          git checkout --detach "$HEAD_SHA"

          # Parent commit of the latest commit
          PARENT_SHA=$(git rev-parse "${HEAD_SHA}^") || true

          if [ -z "$PARENT_SHA" ]; then
            echo "Only one commit found; using initial commit diff."
            # If no parent (edge case), compare against empty tree
            git diff --patch $(git hash-object -t tree /dev/null) "$HEAD_SHA" > pr.diff || true
          else
            git diff --patch "$PARENT_SHA" "$HEAD_SHA" > pr.diff || true
          fi

          # Split diff by file to avoid huge payloads
          csplit -s -f chunk_ -b "%03d.diff" pr.diff '/^diff --git /' '{*}' || true
          [ -s chunk_000.diff ] || rm -f chunk_000.diff
          echo "chunks=$(ls -1 chunk_*.diff 2>/dev/null | wc -l)" >> $GITHUB_OUTPUT

      - name: Build prompt header
        id: header
        run: |
          TITLE=$(jq -r .title pr.json)
          BODY=$(jq -r .body pr.json)
          HEAD=$(jq -r .headRefName pr.json)
          BASE=$(jq -r .baseRefName pr.json)
          AUTHOR=$(jq -r .author.login pr.json)

          echo "You are a senior staff engineer performing a code review for ONLY the latest commit in this PR." > prompt_header.txt
          echo "Focus order: (1) Correctness & security (2) Performance (3) Code quality/style (4) Tests/DX." >> prompt_header.txt
          echo "Be specific; cite filenames and line ranges from the provided diff hunks." >> prompt_header.txt
          echo "Return two sections: BLOCKERS (must-fix) and NON-BLOCKING (nits)." >> prompt_header.txt
          echo "Hard caps: max 10 findings total, ≤3 per file. If more exist, end with \"Overflow: <approximate count>\"." >> prompt_header.txt

          {
            echo "PR Title: ${TITLE}"
            echo "Branch: ${HEAD} -> ${BASE}"
            echo "Author: ${AUTHOR}"
            echo
            echo "PR Description:"
            echo "${BODY}"
          } > pr_context.txt

      - name: Validate API key & model access
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          [ -n "$OPENAI_API_KEY" ] || { echo "OPENAI_API_KEY missing"; exit 1; }
          # cheap model probe (don't spam): list once
          curl -sS --connect-timeout 10 --max-time 20 \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            "$LLM_API_BASE/models" >/dev/null || {
              echo "⚠️ Unable to reach $LLM_API_BASE/models"; exit 1; }

      - name: Probe Responses API (lightweight)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          # Minimal, spec-compliant probe (string input)
          PROBE=$(jq -n --arg model "${LLM_MODEL}" '
            { model: $model, input: "ping", max_output_tokens: 16 }
          ')

          RESP_FILE=$(mktemp)
          HTTP_CODE=$(
            curl -sS --fail-with-body \
              --connect-timeout 10 --max-time 20 \
              -X POST "$LLM_API_BASE/responses" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -H "Content-Type: application/json" \
              -d "$PROBE" \
              -w "%{http_code}" -o "$RESP_FILE" || true
          )

          echo "HTTP=$HTTP_CODE"
          echo "RAW:"
          sed -n '1,120p' "$RESP_FILE"

          # If error, print structured message (helps triage)
          if [ "$HTTP_CODE" -ge 400 ]; then
            if jq -e .error >/dev/null 2>&1 < "$RESP_FILE"; then
              jq .error < "$RESP_FILE"
            fi
            exit 1
          fi

      - name: Review chunks with GPT-5
        id: review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "## 🤖 AI Code Review (Latest Commit Only)" > review.md
          echo >> review.md

          call_llm() {
            local part="$1"
            local DIFF_CONTENT HEADER CONTEXT PAYLOAD RESP_FILE HTTP_CODE TEXT

            DIFF_CONTENT=$(jq -Rs . < "$part")
            HEADER=$(jq -Rs . < prompt_header.txt)
            CONTEXT=$(jq -Rs . < pr_context.txt)

            # Build Responses payload (no temperature for gpt-5)
            # Use content parts format for safer input handling
            PAYLOAD=$(jq -n \
              --arg model "${LLM_MODEL}" \
              --argjson header "$HEADER" \
              --argjson context "$CONTEXT" \
              --argjson diff "$DIFF_CONTENT" '
              {
                model: $model,
                max_output_tokens: 8000,
                input: [
                  {role:"system", content:[{type:"input_text", text: ( $header )}]},
                  {role:"user",   content:[{type:"input_text", text: ( $context )}]},
                  {role:"user",   content:[{type:"input_text", text: "Review ONLY this latest-commit unified diff chunk. Provide: (a) Risks (b) Bugs (c) Perf (d) Style (e) Tests (f) Suggested patch snippets."}]},
                  {role:"user",   content:[{type:"input_text", text: ( $diff )}]}
                ]
              }')

            # Call with strong timeouts + retries and capture status + body separately
            RESP_FILE=$(mktemp)
            HTTP_CODE=$(
              timeout 140s curl -sS --fail-with-body \
                --connect-timeout 10 --max-time 120 \
                --retry 2 --retry-delay 2 --retry-connrefused \
                -X POST "$LLM_API_BASE/responses" \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d "$PAYLOAD" \
                -w "%{http_code}" -o "$RESP_FILE" || true
            )

            # Non-2xx ⇒ show the JSON error (don't swallow it)
            if [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
              echo "> API error on $part (HTTP ${HTTP_CODE:-unknown}):" >> review.md
              if jq -e .error >/dev/null 2>&1 < "$RESP_FILE"; then
                jq -r '.error | "  type: \(.type // "n/a")\n  message: \(.message // "n/a")"' < "$RESP_FILE" >> review.md
              else
                sed -n '1,200p' "$RESP_FILE" >> review.md
              fi
              return 1
            fi

            # Check if response is incomplete
            STATUS=$(jq -r '.status // "unknown"' < "$RESP_FILE")
            if [ "$STATUS" = "incomplete" ]; then
              REASON=$(jq -r '.incomplete_details.reason // "unknown"' < "$RESP_FILE")
              echo "> Incomplete response on $part: $REASON (increase max_output_tokens)" >> review.md
              return 1
            fi

            # Extract text from GPT-5 Responses output
            # GPT-5 returns: .output[0].content[0].text when complete
            TEXT=$(jq -r '
              .output[0].content[0].text // .output_text // empty
            ' < "$RESP_FILE")

            if [ -z "$TEXT" ]; then
              echo "> Empty model output on $part (status: $STATUS)" >> review.md
              echo "> Response structure:" >> review.md
              jq . < "$RESP_FILE" | head -20 >> review.md
              return 1
            fi

            echo "$TEXT" >> review.md
            echo >> review.md
          }

          shopt -s nullglob
          for f in chunk_*.diff; do
            echo "### File chunk: $f" >> review.md

            # Split to MAX_CHUNK_BYTES subparts
            split -b "${MAX_CHUNK_BYTES}" -a 2 -d "$f" "$f."
            for part in $f.*; do
              [ -s "$part" ] || continue
              tries=0
              until call_llm "$part"; do
                tries=$((tries+1))
                [ $tries -ge 3 ] && { echo "> (Giving up on $part)"; break; }
                sleep $((tries*2))
              done

              # Circuit breaker (improved counting)
              FINDINGS=$(grep -E '^(### |[-*] )' review.md | wc -l | tr -d ' ')
              if [ "$FINDINGS" -gt 10 ]; then
                echo "> (Hit findings cap; summarizing rest…)" >> review.md
                break 2
              fi
            done
          done

          if ! grep -q '[A-Za-z0-9]' review.md; then
            echo "_No diff content to review or all chunks failed._" >> review.md
          fi

      - name: Post PR comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR=${{ steps.prnum.outputs.num }}
          gh pr comment "$PR" --body-file review.md

      - name: Add ai-reviewed label
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          PR=${{ steps.prnum.outputs.num }}
          gh pr edit "$PR" --add-label "ai-reviewed" || true
