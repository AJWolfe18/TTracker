<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrumpyTracker Admin</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 50%, #1a202c 100%);
            color: white;
            min-height: 100vh;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .card { 
            background: rgba(45, 55, 72, 0.9); 
            backdrop-filter: blur(10px);
            border-radius: 12px; 
            padding: 24px; 
            margin-bottom: 20px; 
            border: 1px solid #4a5568;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        .input { 
            width: 100%; 
            padding: 12px; 
            background: #2d3748; 
            border: 1px solid #4a5568; 
            border-radius: 8px; 
            color: white; 
            font-size: 14px; 
            box-sizing: border-box; 
        }
        .input:focus { outline: none; border-color: #3182ce; }
        .btn { 
            padding: 10px 16px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-weight: 500; 
            transition: all 0.2s; 
            font-size: 14px; 
        }
        .btn-primary { background: #3182ce; color: white; }
        .btn-primary:hover { background: #2c5aa0; }
        .btn-primary:disabled { background: #4a5568; cursor: not-allowed; }
        .btn-danger { background: #e53e3e; color: white; }
        .btn-danger:hover { background: #c53030; }
        .btn-success { background: #38a169; color: white; }
        .btn-success:hover { background: #2f855a; }
        .btn-secondary { background: #4a5568; color: white; }
        .btn-secondary:hover { background: #2d3748; }
        .btn-warning { background: #d69e2e; color: white; }
        .btn-warning:hover { background: #b7791f; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .gap-4 { gap: 16px; }
        .gap-2 { gap: 8px; }
        .mb-4 { margin-bottom: 16px; }
        .mb-2 { margin-bottom: 8px; }
        .text-center { text-align: center; }
        .text-sm { font-size: 14px; }
        .text-xs { font-size: 12px; }
        .font-bold { font-weight: 700; }
        .grid { display: grid; }
        .grid-2 { grid-template-columns: 1fr 1fr; }
        .entry { 
            background: #2d3748; 
            border: 1px solid #4a5568; 
            border-radius: 8px; 
            padding: 16px; 
            margin-bottom: 12px; 
            cursor: pointer; 
            transition: all 0.2s;
        }
        .entry:hover { background: #374151; transform: translateY(-1px); }
        .entry.selected { border-color: #3182ce; background: rgba(49, 130, 206, 0.1); }
        .entry.editing { border-color: #38a169; background: rgba(56, 161, 105, 0.1); cursor: default; }
        .entry.failed { border-left: 4px solid #e53e3e; }
        .entry.published { border-left: 4px solid #38a169; }
        .badge { padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; }
        .badge-high { background: rgba(229, 62, 62, 0.2); color: #fed7d7; border: 1px solid #e53e3e; }
        .badge-medium { background: rgba(237, 137, 54, 0.2); color: #feebc8; border: 1px solid #ed8936; }
        .badge-low { background: rgba(56, 161, 105, 0.2); color: #c6f6d5; border: 1px solid #38a169; }
        .badge-archived { background: rgba(128, 90, 213, 0.2); color: #e9d8fd; border: 1px solid #805ad5; }
        .badge-published { background: rgba(56, 161, 105, 0.2); color: #c6f6d5; border: 1px solid #38a169; }
        .badge-failed { background: rgba(229, 62, 62, 0.2); color: #fed7d7; border: 1px solid #e53e3e; }
        .logo { 
            width: 40px; 
            height: 40px; 
            background: linear-gradient(135deg, #e53e3e 0%, #3182ce 100%); 
            border-radius: 8px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
        }
        .message { padding: 12px; border-radius: 8px; margin-bottom: 16px; }
        .message-success { background: rgba(56, 161, 105, 0.2); color: #c6f6d5; border: 1px solid #38a169; }
        .message-error { background: rgba(229, 62, 62, 0.2); color: #fed7d7; border: 1px solid #e53e3e; }
        .message-info { background: rgba(49, 130, 206, 0.2); color: #bee3f8; border: 1px solid #3182ce; }
        .scrollable { height: calc(100vh - 420px); overflow-y: auto; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 20px; }
        .stat-card { background: #374151; padding: 16px; border-radius: 8px; text-align: center; }
        @media (max-width: 768px) {
            .grid-2 { grid-template-columns: 1fr; }
            .flex-mobile { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback } = React;

        function AdminApp() {
            // === STATE MANAGEMENT ===
            const [isAuthenticated, setIsAuthenticated] = useState(false);
            const [token, setToken] = useState('');
            const [entries, setEntries] = useState([]);
            const [selectedEntries, setSelectedEntries] = useState(new Set());
            const [searchTerm, setSearchTerm] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [message, setMessage] = useState(null);
            const [showArchived, setShowArchived] = useState(false);
            const [editingEntry, setEditingEntry] = useState(null);
            const [editForm, setEditForm] = useState({});
            const [submissionUrl, setSubmissionUrl] = useState('');
            const [isSubmitting, setIsSubmitting] = useState(false);
            const [statusFilter, setStatusFilter] = useState('all');

            // === UTILITY FUNCTIONS ===
            const generateId = () => {
                return Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            };

            const encodeBase64 = (str) => {
                try {
                    return btoa(unescape(encodeURIComponent(str)));
                } catch {
                    return btoa(str);
                }
            };

            const showMessage = useCallback((text, type = 'info') => {
                setMessage({ text, type });
                const timeoutId = setTimeout(() => setMessage(null), 5000);
                return () => clearTimeout(timeoutId);
            }, []);

            const formatDate = useCallback((dateString) => {
                try {
                    return new Date(dateString).toLocaleDateString();
                } catch {
                    return 'Invalid Date';
                }
            }, []);

            const formatDateTime = useCallback((dateString) => {
                try {
                    return new Date(dateString).toLocaleString();
                } catch {
                    return 'Invalid Date';
                }
            }, []);

            const getSeverityClasses = useCallback((severity) => {
                switch (severity) {
                    case 'high': return 'badge badge-high';
                    case 'medium': return 'badge badge-medium';
                    case 'low': return 'badge badge-low';
                    default: return 'badge';
                }
            }, []);

            const getStatusClasses = useCallback((status) => {
                switch (status) {
                    case 'published': return 'badge badge-published';
                    case 'failed': return 'badge badge-failed';
                    default: return 'badge badge-published'; // Default to published for legacy entries
                }
            }, []);

            // === AUTHENTICATION ===
            const authenticate = async () => {
                if (!token.trim()) {
                    showMessage('Please enter your GitHub token', 'error');
                    return;
                }
                if (!token.startsWith('github_pat_') && !token.startsWith('ghp_')) {
                    showMessage('Token must start with github_pat_ or ghp_', 'error');
                    return;
                }

                try {
                    setIsLoading(true);
                    const response = await fetch('https://api.github.com/user', {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (!response.ok) {
                        throw new Error('Invalid GitHub token');
                    }

                    setIsAuthenticated(true);
                    sessionStorage.setItem('admin_token', token);
                    await loadEntries();
                    showMessage('✅ Login successful', 'success');
                } catch (error) {
                    showMessage(`❌ Authentication failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const logout = () => {
                setIsAuthenticated(false);
                setToken('');
                sessionStorage.removeItem('admin_token');
                setEntries([]);
                setSelectedEntries(new Set());
                setMessage(null);
            };

            // === DATA OPERATIONS ===
            const loadEntries = async () => {
                try {
                    setIsLoading(true);
                    const response = await fetch('/master-tracker-log.json');
                    if (!response.ok) throw new Error('Failed to load entries');
                    const data = await response.json();
                    
                    // Add default status to legacy entries that don't have one
                    const entriesWithStatus = (Array.isArray(data) ? data : []).map(entry => ({
                        ...entry,
                        status: entry.status || 'published' // Default legacy entries to published
                    }));
                    
                    setEntries(entriesWithStatus);
                    showMessage(`📊 Loaded ${entriesWithStatus.length} entries`, 'success');
                } catch (error) {
                    showMessage(`❌ Error loading entries: ${error.message}`, 'error');
                    setEntries([]);
                } finally {
                    setIsLoading(false);
                }
            };

            const updateGitHubFile = async (newData, fileName = 'master-tracker-log.json') => {
                const repo = 'AJWolfe18/TTracker';
                const path = fileName;
                
                try {
                    const getResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${path}?ref=main`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    let fileInfo = null;
                    if (getResponse.ok) {
                        fileInfo = await getResponse.json();
                    }
                    
                    const updateResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${path}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            message: `Admin update: ${fileName}`,
                            content: encodeBase64(JSON.stringify(newData, null, 2)),
                            sha: fileInfo?.sha
                        })
                    });
                    
                    if (!updateResponse.ok) {
                        throw new Error(`GitHub update failed: ${updateResponse.status}`);
                    }
                    
                    // Update public file for master tracker
                    if (fileName === 'master-tracker-log.json') {
                        try {
                            const publicPath = `public/${fileName}`;
                            const publicGetResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${publicPath}?ref=main`, {
                                headers: { 'Authorization': `Bearer ${token}` }
                            });
                            
                            let publicFileInfo = null;
                            if (publicGetResponse.ok) {
                                publicFileInfo = await publicGetResponse.json();
                            }
                            
                            await fetch(`https://api.github.com/repos/${repo}/contents/${publicPath}`, {
                                method: 'PUT',
                                headers: {
                                    'Authorization': `Bearer ${token}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: `Admin update: public/${fileName}`,
                                    content: encodeBase64(JSON.stringify(newData, null, 2)),
                                    sha: publicFileInfo?.sha
                                })
                            });
                        } catch (publicError) {
                            console.warn('Could not update public file:', publicError);
                        }
                    }
                    
                    return true;
                } catch (error) {
                    console.error('GitHub update error:', error);
                    throw error;
                }
            };

            // === MANUAL ARTICLE SUBMISSION ===
            const submitManualArticle = async () => {
                if (!submissionUrl.trim()) return;
                
                try {
                    setIsSubmitting(true);
                    
                    // Validate URL
                    try {
                        new URL(submissionUrl);
                    } catch {
                        throw new Error('Please enter a valid URL');
                    }
                    
                    // Check for duplicates
                    const duplicates = entries.filter(entry => entry.source_url === submissionUrl);
                    if (duplicates.length > 0) {
                        const override = confirm(`⚠️ Duplicate found: "${duplicates[0].title}"\n\nSubmit anyway?`);
                        if (!override) {
                            setIsSubmitting(false);
                            return;
                        }
                    }
                    
                    showMessage('📝 Processing article...', 'info');
                    
                    // Trigger GitHub Actions workflow directly
                    const workflowResponse = await fetch(`https://api.github.com/repos/AJWolfe18/TTracker/dispatches`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            event_type: 'process-manual-article',
                            client_payload: {
                                article_url: submissionUrl,
                                submitted_by: 'admin',
                                submitted_at: new Date().toISOString()
                            }
                        })
                    });
                    
                    if (!workflowResponse.ok) {
                        throw new Error(`Workflow trigger failed: ${workflowResponse.status}`);
                    }
                    
                    setSubmissionUrl('');
                    showMessage('✅ Article submitted for processing! Check back in a few minutes.', 'success');
                    
                    // Auto-refresh after delay
                    setTimeout(() => loadEntries(), 30000);
                    
                } catch (error) {
                    showMessage(`❌ Submission failed: ${error.message}`, 'error');
                } finally {
                    setIsSubmitting(false);
                }
            };

            // === STATUS OPERATIONS ===
            const retrySelected = async () => {
                if (selectedEntries.size === 0) return;
                
                const failedEntries = entries.filter(entry => 
                    selectedEntries.has(entry.id) && entry.status === 'failed'
                );
                
                if (failedEntries.length === 0) {
                    showMessage('No failed entries selected', 'error');
                    return;
                }
                
                try {
                    setIsLoading(true);
                    
                    // Trigger workflows for each failed entry
                    for (const entry of failedEntries) {
                        await fetch(`https://api.github.com/repos/AJWolfe18/TTracker/dispatches`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${token}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                event_type: 'process-manual-article',
                                client_payload: {
                                    article_url: entry.source_url,
                                    submitted_by: entry.submitted_by || 'admin',
                                    submitted_at: new Date().toISOString(),
                                    retry: true
                                }
                            })
                        });
                    }
                    
                    setSelectedEntries(new Set());
                    showMessage(`🔄 Retrying ${failedEntries.length} failed submissions`, 'success');
                    
                } catch (error) {
                    showMessage(`❌ Retry failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const markAsPublished = async () => {
                if (selectedEntries.size === 0) return;
                
                try {
                    setIsLoading(true);
                    const updatedEntries = entries.map(entry => 
                        selectedEntries.has(entry.id) 
                            ? { ...entry, status: 'published', error_message: undefined }
                            : entry
                    );
                    await updateGitHubFile(updatedEntries);
                    setEntries(updatedEntries);
                    setSelectedEntries(new Set());
                    showMessage(`✅ Marked ${selectedEntries.size} entries as published`, 'success');
                } catch (error) {
                    showMessage(`❌ Update failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            // === ENTRY MANAGEMENT ===
            const archiveSelected = async () => {
                if (selectedEntries.size === 0) return;
                if (!confirm(`Archive ${selectedEntries.size} entries?`)) return;
                
                try {
                    setIsLoading(true);
                    const updated = entries.map(entry => 
                        selectedEntries.has(entry.id) 
                            ? { ...entry, archived: true, archived_at: new Date().toISOString() }
                            : entry
                    );
                    await updateGitHubFile(updated);
                    setEntries(updated);
                    setSelectedEntries(new Set());
                    showMessage(`🗃️ Archived ${selectedEntries.size} entries`, 'success');
                } catch (error) {
                    showMessage(`❌ Archive failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const restoreSelected = async () => {
                if (selectedEntries.size === 0) return;
                
                try {
                    setIsLoading(true);
                    const updated = entries.map(entry => {
                        if (selectedEntries.has(entry.id)) {
                            const { archived, archived_at, ...restored } = entry;
                            return restored;
                        }
                        return entry;
                    });
                    await updateGitHubFile(updated);
                    setEntries(updated);
                    setSelectedEntries(new Set());
                    showMessage(`🔄 Restored ${selectedEntries.size} entries`, 'success');
                } catch (error) {
                    showMessage(`❌ Restore failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const deleteSelected = async () => {
                if (selectedEntries.size === 0) return;
                if (!confirm(`PERMANENTLY delete ${selectedEntries.size} entries?`)) return;
                
                try {
                    setIsLoading(true);
                    const updated = entries.filter(entry => !selectedEntries.has(entry.id));
                    await updateGitHubFile(updated);
                    setEntries(updated);
                    setSelectedEntries(new Set());
                    showMessage(`🗑️ Deleted ${selectedEntries.size} entries`, 'success');
                } catch (error) {
                    showMessage(`❌ Delete failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const startEdit = (entry) => {
                setEditingEntry(entry.id);
                setEditForm({
                    title: entry.title || '',
                    description: entry.description || '',
                    actor: entry.actor || '',
                    category: entry.category || 'Government Oversight',
                    severity: entry.severity || 'medium',
                    source_url: entry.source_url || '',
                    verified: Boolean(entry.verified),
                    date: entry.date || new Date().toISOString().split('T')[0],
                    status: entry.status || 'published'
                });
            };

            const saveEdit = async () => {
                try {
                    setIsLoading(true);
                    const updated = entries.map(entry => 
                        entry.id === editingEntry 
                            ? { ...entry, ...editForm, modified_at: new Date().toISOString() }
                            : entry
                    );
                    await updateGitHubFile(updated);
                    setEntries(updated);
                    setEditingEntry(null);
                    setEditForm({});
                    showMessage('✅ Entry updated', 'success');
                } catch (error) {
                    showMessage(`❌ Save failed: ${error.message}`, 'error');
                } finally {
                    setIsLoading(false);
                }
            };

            const cancelEdit = () => {
                setEditingEntry(null);
                setEditForm({});
            };

            const toggleSelection = (entryId) => {
                const newSelected = new Set(selectedEntries);
                if (newSelected.has(entryId)) {
                    newSelected.delete(entryId);
                } else {
                    newSelected.add(entryId);
                }
                setSelectedEntries(newSelected);
            };

            const selectAll = () => {
                const filtered = getFilteredEntries();
                if (selectedEntries.size === filtered.length) {
                    setSelectedEntries(new Set());
                } else {
                    setSelectedEntries(new Set(filtered.map(e => e.id)));
                }
            };

            const getFilteredEntries = () => {
                return entries.filter(entry => {
                    // Archive filter
                    if (showArchived && !entry.archived) return false;
                    if (!showArchived && entry.archived) return false;
                    
                    // Status filter
                    if (statusFilter !== 'all' && entry.status !== statusFilter) return false;
                    
                    // Search filter
                    if (!searchTerm) return true;
                    const searchLower = searchTerm.toLowerCase();
                    return Object.values(entry).some(val => 
                        val?.toString().toLowerCase().includes(searchLower)
                    );
                });
            };

            // === EFFECTS ===
            useEffect(() => {
                const savedToken = sessionStorage.getItem('admin_token');
                if (savedToken) setToken(savedToken);
            }, []);

            // === COMPUTED VALUES ===
            const filteredEntries = getFilteredEntries();
            const statusStats = {
                total: entries.filter(e => !e.archived).length,
                published: entries.filter(e => !e.archived && (e.status === 'published' || !e.status)).length,
                failed: entries.filter(e => !e.archived && e.status === 'failed').length
            };

            // === RENDER ===
            if (!isAuthenticated) {
                return (
                    <div className="container">
                        <div style={{ maxWidth: '400px', margin: '100px auto' }}>
                            <div className="card text-center">
                                <div className="logo" style={{ margin: '0 auto 20px' }}>T2</div>
                                <h1 style={{ margin: '0 0 20px', background: 'linear-gradient(135deg, #60a5fa 0%, #ef4444 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>
                                    TrumpyTracker Admin
                                </h1>
                                
                                <div style={{ marginBottom: '16px' }}>
                                    <label style={{ display: 'block', marginBottom: '8px', fontSize: '14px' }}>
                                        🔐 GitHub Token:
                                    </label>
                                    <input
                                        type="password"
                                        value={token}
                                        onChange={(e) => setToken(e.target.value)}
                                        onKeyPress={(e) => e.key === 'Enter' && authenticate()}
                                        className="input"
                                        placeholder="github_pat_... or ghp_..."
                                        disabled={isLoading}
                                    />
                                </div>
                                
                                <button 
                                    onClick={authenticate} 
                                    disabled={isLoading}
                                    className="btn btn-primary" 
                                    style={{ width: '100%' }}
                                >
                                    {isLoading ? '🔄 Authenticating...' : '🚀 Login'}
                                </button>
                                
                                {message && (
                                    <div className={`message message-${message.type}`}>
                                        {message.text}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="container">
                    {/* Header */}
                    <div className="card">
                        <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-4">
                                <div className="logo">T2</div>
                                <div>
                                    <h1 style={{ margin: 0, background: 'linear-gradient(135deg, #60a5fa 0%, #ef4444 100%)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>
                                        Admin Panel
                                    </h1>
                                    <div style={{ fontSize: '14px', color: '#a0aec0' }}>Political Tracker Management</div>
                                </div>
                            </div>
                            <button onClick={logout} className="btn btn-danger">
                                🚪 Logout
                            </button>
                        </div>
                        
                        {/* Manual Article Submission */}
                        <div className="flex gap-4 mb-4 flex-mobile">
                            <input
                                type="url"
                                value={submissionUrl}
                                onChange={(e) => setSubmissionUrl(e.target.value)}
                                placeholder="📎 Paste article URL to submit manually..."
                                className="input"
                                style={{ flex: 1 }}
                                disabled={isSubmitting}
                            />
                            <button 
                                onClick={submitManualArticle} 
                                disabled={!submissionUrl.trim() || isSubmitting || isLoading} 
                                className="btn btn-success"
                            >
                                {isSubmitting ? '🔄 Processing...' : '📰 Submit Article'}
                            </button>
                        </div>

                        {/* Entry Status Overview */}
                        <div className="stats-grid">
                            <div className="stat-card">
                                <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#60a5fa' }}>{statusStats.total}</div>
                                <div style={{ fontSize: '14px', color: '#a0aec0' }}>Total Active</div>
                            </div>
                            <div className="stat-card">
                                <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#4ade80' }}>{statusStats.published}</div>
                                <div style={{ fontSize: '14px', color: '#a0aec0' }}>Published</div>
                            </div>
                            <div className="stat-card">
                                <div style={{ fontSize: '24px', fontWeight: 'bold', color: '#f87171' }}>{statusStats.failed}</div>
                                <div style={{ fontSize: '14px', color: '#a0aec0' }}>Failed</div>
                            </div>
                        </div>

                        {/* Unified Controls */}
                        <div className="flex gap-4 mb-4 flex-mobile">
                            <input
                                type="text"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                placeholder="🔍 Search entries..."
                                className="input"
                                style={{ flex: 1 }}
                            />
                            <select
                                value={statusFilter}
                                onChange={(e) => setStatusFilter(e.target.value)}
                                className="input"
                                style={{ minWidth: '150px' }}
                            >
                                <option value="all">All Status</option>
                                <option value="published">✅ Published</option>
                                <option value="failed">❌ Failed</option>
                            </select>
                            <button onClick={loadEntries} disabled={isLoading} className="btn btn-primary">
                                {isLoading ? '🔄' : '📊'} Refresh
                            </button>
                        </div>
                        
                        <div className="flex gap-2 mb-4 flex-mobile">
                            <span className="text-sm" style={{ color: '#a0aec0' }}>
                                📋 {filteredEntries.length} entries ({selectedEntries.size} selected)
                            </span>
                            <button
                                onClick={() => setShowArchived(!showArchived)}
                                className="btn btn-secondary"
                            >
                                {showArchived ? '📂 Active' : '🗃️ Archives'}
                            </button>
                            <button onClick={selectAll} className="btn btn-secondary">
                                {selectedEntries.size === filteredEntries.length ? '❌ None' : '✅ All'}
                            </button>
                            <button onClick={markAsPublished} disabled={selectedEntries.size === 0 || isLoading} className="btn btn-success">
                                ✅ Mark Published ({selectedEntries.size})
                            </button>
                            {!showArchived ? (
                                <button onClick={archiveSelected} disabled={selectedEntries.size === 0 || isLoading} className="btn btn-secondary">
                                    🗃️ Archive ({selectedEntries.size})
                                </button>
                            ) : (
                                <button onClick={restoreSelected} disabled={selectedEntries.size === 0 || isLoading} className="btn btn-success">
                                    🔄 Restore ({selectedEntries.size})
                                </button>
                            )}
                            <button onClick={deleteSelected} disabled={selectedEntries.size === 0 || isLoading} className="btn btn-danger">
                                🗑️ Delete ({selectedEntries.size})
                            </button>
                            {statusStats.failed > 0 && (
                                <button 
                                    onClick={() => {
                                        const failedEntries = entries.filter(e => e.status === 'failed' && !e.archived);
                                        setSelectedEntries(new Set(failedEntries.map(e => e.id)));
                                        retrySelected();
                                    }} 
                                    className="btn btn-warning"
                                    disabled={isLoading}
                                >
                                    🔄 Retry All Failed ({statusStats.failed})
                                </button>
                            )}
                        </div>
                    </div>

                    {/* Messages */}
                    {message && (
                        <div className={`message message-${message.type}`}>
                            {message.text}
                        </div>
                    )}

                    {/* Entries List */}
                    <div className="card">
                        <div className="scrollable">
                            {filteredEntries.length === 0 ? (
                                <div className="text-center" style={{ padding: '40px' }}>
                                    <div style={{ fontSize: '48px', marginBottom: '16px' }}>📊</div>
                                    <div style={{ color: '#a0aec0' }}>No entries found</div>
                                </div>
                            ) : (
                                filteredEntries.map(entry => (
                                    <div
                                        key={entry.id}
                                        className={`entry ${selectedEntries.has(entry.id) ? 'selected' : ''} ${editingEntry === entry.id ? 'editing' : ''} ${entry.status || 'published'}`}
                                        onClick={() => editingEntry !== entry.id && toggleSelection(entry.id)}
                                    >
                                        {editingEntry === entry.id ? (
                                            <div>
                                                <div className="grid grid-2 gap-4 mb-4">
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Date</label>
                                                        <input
                                                            type="date"
                                                            value={editForm.date}
                                                            onChange={(e) => setEditForm({...editForm, date: e.target.value})}
                                                            className="input"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Status</label>
                                                        <select
                                                            value={editForm.status}
                                                            onChange={(e) => setEditForm({...editForm, status: e.target.value})}
                                                            className="input"
                                                        >
                                                            <option value="published">✅ Published</option>
                                                            <option value="failed">❌ Failed</option>
                                                        </select>
                                                    </div>
                                                </div>
                                                
                                                <div className="grid grid-2 gap-4 mb-4">
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Severity</label>
                                                        <select
                                                            value={editForm.severity}
                                                            onChange={(e) => setEditForm({...editForm, severity: e.target.value})}
                                                            className="input"
                                                        >
                                                            <option value="low">🟢 Low</option>
                                                            <option value="medium">🟡 Medium</option>
                                                            <option value="high">🔴 High</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Actor</label>
                                                        <input
                                                            type="text"
                                                            value={editForm.actor}
                                                            onChange={(e) => setEditForm({...editForm, actor: e.target.value})}
                                                            className="input"
                                                        />
                                                    </div>
                                                </div>
                                                
                                                <div className="mb-4">
                                                    <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Title</label>
                                                    <input
                                                        type="text"
                                                        value={editForm.title}
                                                        onChange={(e) => setEditForm({...editForm, title: e.target.value})}
                                                        className="input"
                                                    />
                                                </div>
                                                
                                                <div className="mb-4">
                                                    <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Description</label>
                                                    <textarea
                                                        value={editForm.description}
                                                        onChange={(e) => setEditForm({...editForm, description: e.target.value})}
                                                        className="input"
                                                        rows="3"
                                                    />
                                                </div>
                                                
                                                <div className="grid grid-2 gap-4 mb-4">
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Category</label>
                                                        <select
                                                            value={editForm.category}
                                                            onChange={(e) => setEditForm({...editForm, category: e.target.value})}
                                                            className="input"
                                                        >
                                                            <option value="Financial">Financial</option>
                                                            <option value="Civil Liberties">Civil Liberties</option>
                                                            <option value="Platform Manipulation">Platform Manipulation</option>
                                                            <option value="Government Oversight">Government Oversight</option>
                                                            <option value="Election Integrity">Election Integrity</option>
                                                            <option value="Corporate Ethics">Corporate Ethics</option>
                                                            <option value="Legal Proceedings">Legal Proceedings</option>
                                                        </select>
                                                    </div>
                                                    <div>
                                                        <label style={{ display: 'block', marginBottom: '4px', fontSize: '12px', color: '#a0aec0' }}>Source URL</label>
                                                        <input
                                                            type="url"
                                                            value={editForm.source_url}
                                                            onChange={(e) => setEditForm({...editForm, source_url: e.target.value})}
                                                            className="input"
                                                        />
                                                    </div>
                                                </div>
                                                
                                                <div className="mb-4">
                                                    <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
                                                        <input
                                                            type="checkbox"
                                                            checked={editForm.verified}
                                                            onChange={(e) => setEditForm({...editForm, verified: e.target.checked})}
                                                        />
                                                        <span style={{ fontSize: '14px' }}>✅ Verified Source</span>
                                                    </label>
                                                </div>
                                                
                                                <div className="flex gap-2">
                                                    <button onClick={saveEdit} disabled={isLoading} className="btn btn-success">
                                                        💾 Save
                                                    </button>
                                                    <button onClick={cancelEdit} className="btn btn-secondary">
                                                        ❌ Cancel
                                                    </button>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex justify-between">
                                                <div style={{ flex: 1 }}>
                                                    <div className="flex items-center gap-2 mb-2">
                                                        <span className="text-sm" style={{ color: '#a0aec0' }}>📅 {formatDate(entry.date)}</span>
                                                        <span className={getStatusClasses(entry.status)}>
                                                            {entry.status === 'failed' ? '❌ FAILED' : '✅ PUBLISHED'}
                                                        </span>
                                                        <span className={getSeverityClasses(entry.severity)}>
                                                            {entry.severity === 'high' ? '🚨 HIGH' :
                                                             entry.severity === 'medium' ? '⚠️ MEDIUM' : 'ℹ️ LOW'}
                                                        </span>
                                                        {entry.verified && <span className="text-green-400 text-sm">✅ Verified</span>}
                                                        {entry.archived && <span className="badge badge-archived">🗃️ Archived</span>}
                                                        <span className="text-sm" style={{ color: '#60a5fa' }}>{entry.actor}</span>
                                                    </div>
                                                    <h3 style={{ margin: '0 0 8px', fontWeight: 600 }}>{entry.title}</h3>
                                                    <p style={{ margin: '0 0 8px', fontSize: '14px', color: '#d1d5db' }}>{entry.description}</p>
                                                    {entry.error_message && (
                                                        <p style={{ margin: '0 0 8px', fontSize: '14px', color: '#f87171' }}>
                                                            ❌ Error: {entry.error_message}
                                                        </p>
                                                    )}
                                                    <div className="flex items-center gap-4 text-xs" style={{ color: '#a0aec0' }}>
                                                        <span>📁 {entry.category}</span>
                                                        {entry.retry_count && <span>🔄 Retry #{entry.retry_count}</span>}
                                                        {entry.source_url && (
                                                            <a 
                                                                href={entry.source_url} 
                                                                target="_blank" 
                                                                rel="noopener noreferrer"
                                                                className="text-blue-400 hover:text-blue-300"
                                                                onClick={(e) => e.stopPropagation()}
                                                            >
                                                                🔗 Source
                                                            </a>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="flex items-start gap-2" style={{ marginLeft: '16px' }}>
                                                    {entry.status === 'failed' && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                setSelectedEntries(new Set([entry.id]));
                                                                retrySelected();
                                                            }}
                                                            className="btn btn-warning"
                                                            style={{ padding: '4px 8px', fontSize: '12px' }}
                                                            disabled={isLoading}
                                                        >
                                                            🔄 Retry
                                                        </button>
                                                    )}
                                                    <button
                                                        onClick={(e) => { e.stopPropagation(); startEdit(entry); }}
                                                        className="btn btn-primary"
                                                        style={{ padding: '6px 12px', fontSize: '12px' }}
                                                    >
                                                        ✏️ Edit
                                                    </button>
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedEntries.has(entry.id)}
                                                        onChange={(e) => { e.stopPropagation(); toggleSelection(entry.id); }}
                                                        style={{ marginTop: '4px' }}
                                                    />
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<AdminApp />, document.getElementById('root'));
    </script>
</body>
</html>
