// EXPERT REVIEWED QUEUE LOADING SOLUTION
// This fixes the file access pattern mismatch

const loadQueueData = useCallback(async () => {
    try {
        setQueueLoading(true);
        
        // SOLUTION: Try public path first, fallback to GitHub API
        await loadQueueFiles();
        
    } catch (error) {
        console.warn('Queue loading failed (expected for new deployments):', error.message);
        // Set empty state - this is expected behavior
        setPendingSubmissions([]);
        setFailedSubmissions([]);
    } finally {
        setQueueLoading(false);
    }
}, []);

const loadQueueFiles = useCallback(async () => {
    // Try public folder access first (fastest, CORS-safe)
    try {
        const [pendingResp, failedResp] = await Promise.allSettled([
            fetch('/pending-submissions.json'),
            fetch('/failed-submissions.json')
        ]);
        
        // Process pending submissions
        if (pendingResp.status === 'fulfilled' && pendingResp.value.ok) {
            const pendingData = await pendingResp.value.json();
            setPendingSubmissions(Array.isArray(pendingData) ? pendingData : []);
        } else {
            // Fallback to GitHub API for pending
            await loadPendingViaAPI();
        }
        
        // Process failed submissions  
        if (failedResp.status === 'fulfilled' && failedResp.value.ok) {
            const failedData = await failedResp.value.json();
            setFailedSubmissions(Array.isArray(failedData) ? failedData : []);
        } else {
            // Fallback to GitHub API for failed
            await loadFailedViaAPI();
        }
        
    } catch (error) {
        // Final fallback - try GitHub API
        console.log('Public file access failed, trying GitHub API...');
        await Promise.allSettled([
            loadPendingViaAPI(),
            loadFailedViaAPI()
        ]);
    }
}, [token]);

const loadPendingViaAPI = useCallback(async () => {
    try {
        const response = await fetch(`https://api.github.com/repos/AJWolfe18/TTracker/contents/pending-submissions.json?ref=main`, {
            headers: { 
                'Authorization': `Bearer ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const fileData = await response.json();
            const content = atob(fileData.content);
            const data = JSON.parse(content);
            setPendingSubmissions(Array.isArray(data) ? data : []);
        } else if (response.status === 404) {
            // File doesn't exist yet - normal for new deployment
            setPendingSubmissions([]);
        } else {
            throw new Error(`GitHub API error: ${response.status}`);
        }
    } catch (error) {
        console.warn('Could not load pending submissions:', error.message);
        setPendingSubmissions([]);
    }
}, [token]);

const loadFailedViaAPI = useCallback(async () => {
    try {
        const response = await fetch(`https://api.github.com/repos/AJWolfe18/TTracker/contents/failed-submissions.json?ref=main`, {
            headers: { 
                'Authorization': `Bearer ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const fileData = await response.json();
            const content = atob(fileData.content);
            const data = JSON.parse(content);
            setFailedSubmissions(Array.isArray(data) ? data : []);
        } else if (response.status === 404) {
            // File doesn't exist yet - normal for new deployment
            setFailedSubmissions([]);
        } else {
            throw new Error(`GitHub API error: ${response.status}`);
        }
    } catch (error) {
        console.warn('Could not load failed submissions:', error.message);
        setFailedSubmissions([]);
    }
}, [token]);
