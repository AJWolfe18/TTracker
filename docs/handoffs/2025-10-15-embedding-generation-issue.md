# Embedding Generation Issue - TTRC-231 Testing Blocker

**Date:** 2025-10-15
**Priority:** HIGH - Blocks merge quality testing
**Status:** Investigation Complete, Architecture Decision Needed

---

## 🔴 Problem Statement

**Cannot run merge quality tests** because we only have 5 stories with embeddings. Need 10+ stories with embeddings to create realistic test scenarios.

**Root Cause:** RSS pipeline creates articles **WITHOUT** embeddings, causing downstream clustering and merge detection to fail.

---

## 📊 Current State

- **Total stories:** 140
- **Stories with embeddings:** 5 (3.5%)
- **Recent RSS fetch:** Created 40+ articles, none have embeddings
- **Enrichment jobs:** Completed for 20 stories, but didn't create embeddings
- **Clustering:** Requires articles to have embeddings BEFORE clustering

---

## 🔍 Technical Details

### Current Flow (BROKEN)

```
1. RSS Fetch (scripts/rss/fetch_feed.js)
   ├─ Creates articles via upsert_article_and_enqueue_jobs RPC
   ├─ Article.embedding_v1 = NULL ❌
   └─ Enqueues story.cluster job

2. Story Clustering (scripts/rss/hybrid-clustering.js)
   ├─ Expects article.embedding_v1 to exist
   ├─ Uses embeddings for ANN candidate search (line 115)
   ├─ Uses embeddings for similarity scoring (line 136)
   └─ Copies article.embedding_v1 → story.centroid_embedding_v1 (line 241)

3. Story Enrichment (scripts/job-queue-worker.js:enrichStory)
   ├─ Generates summaries, categories, primary_actor ✅
   ├─ Does NOT generate embeddings ❌
   └─ Result: Stories have summaries but NULL centroid

4. Merge Detection (scripts/rss/periodic-merge.js)
   ├─ Requires story.centroid_embedding_v1 for similarity comparison
   ├─ Filters out stories with NULL centroids
   └─ Result: Can't test merge detection without embeddings
```

### What Embeddings Are

- **Vector representation of text** (1,536 dimensions)
- Generated by **OpenAI text-embedding-3-small** model
- Cost: **$0.02 / 1M tokens** (~$0.0002 per article)
- Used for semantic similarity comparison (cosine similarity)

---

## 💡 Proposed Solutions

### **Option 1: Add Article Enrichment Job** (RECOMMENDED)

**Description:** Create new `article.enrich` job that generates embeddings after RSS fetch

**Implementation:**
1. Modify `upsert_article_and_enqueue_jobs` RPC to enqueue `article.enrich` job
2. Create `enrichArticle()` handler in job-queue-worker.js:
   ```javascript
   async enrichArticle(payload) {
     const { article_id } = payload;

     // 1. Fetch article
     const { data: article } = await supabase
       .from('articles')
       .select('title, content')
       .eq('id', article_id)
       .single();

     // 2. Generate embedding
     const embedding = await openai.embeddings.create({
       model: 'text-embedding-3-small',
       input: `${article.title}\n\n${article.content.slice(0, 2000)}`
     });

     // 3. Update article
     await supabase
       .from('articles')
       .update({ embedding_v1: embedding.data[0].embedding })
       .eq('id', article_id);
   }
   ```
3. Clustering job waits for embedding before processing

**Pros:**
- ✅ Separates concerns (fetch → enrich → cluster)
- ✅ Uses existing job queue retry logic
- ✅ Can batch embeddings for cost efficiency
- ✅ Non-blocking (RSS fetch stays fast)
- ✅ Matches existing enrichment pattern

**Cons:**
- ⚠️ Adds latency (embedding → cluster is sequential)
- ⚠️ More complex workflow (3 job types instead of 2)

**Cost:** ~$0.0002 per article × 40 articles/day = **$0.008/day** (~$0.25/month)

---

### **Option 2: Embed During RSS Fetch**

**Description:** Add embedding generation directly in `fetch_feed.js`

**Implementation:**
1. After creating article, call OpenAI immediately:
   ```javascript
   // In processArticleItemAtomic()
   const embedding = await openai.embeddings.create({
     model: 'text-embedding-3-small',
     input: `${title}\n\n${content.slice(0, 2000)}`
   });

   // Pass embedding to RPC
   await db.rpc('upsert_article_and_enqueue_jobs', {
     ...existing_params,
     p_embedding: embedding.data[0].embedding
   });
   ```

**Pros:**
- ✅ Simpler workflow (fetch+embed → cluster)
- ✅ Embeddings available immediately
- ✅ One less job type to maintain

**Cons:**
- ❌ Blocks RSS fetch (adds 500-1000ms per article)
- ❌ No retry logic if embedding fails
- ❌ Couples RSS parsing with AI service
- ❌ Harder to batch/optimize

**Cost:** Same as Option 1 (~$0.25/month)

---

### **Option 3: Embed During Clustering**

**Description:** Generate embeddings in `hybrid-clustering.js` before scoring

**Implementation:**
1. Check if article.embedding_v1 is NULL
2. If NULL, generate embedding before candidate search
3. Update article with embedding

**Pros:**
- ✅ No new job type needed
- ✅ Embeddings generated only for articles that get clustered

**Cons:**
- ❌ Couples clustering with AI service
- ❌ Blocks clustering job (adds latency)
- ❌ May generate embeddings for articles that fail clustering

**Cost:** Same as Option 1 (~$0.25/month)

---

## 🎯 Recommendation

**Option 1: Add Article Enrichment Job**

**Why:**
1. **Separation of concerns** - Each job does one thing well
2. **Resilience** - Job queue handles retries, failures gracefully
3. **Future-proof** - Easy to add more article enrichment later (entities, sentiment, etc.)
4. **Cost-effective** - Can batch embeddings if needed
5. **Follows existing pattern** - Matches story enrichment workflow

**Implementation Effort:** ~2-3 hours
- 1 hour: Write `enrichArticle()` handler + update RPC
- 1 hour: Test with sample articles
- 30 min: Backfill existing 40 articles
- 30 min: Verify merge quality tests work

---

## 📋 Next Steps (If Option 1 Approved)

1. **Update RPC** (`upsert_article_and_enqueue_jobs`) to create `article.enrich` job
2. **Add handler** in `job-queue-worker.js`
3. **Test** with 5 sample articles
4. **Backfill** existing 40 articles from today's RSS fetch
5. **Run merge quality tests** with 20+ enriched stories
6. **Document** in CLAUDE.md and architecture docs

---

## 💰 Cost Analysis

### One-Time Backfill (40 articles)
- 40 articles × $0.0002 = **$0.008** (less than 1 cent)

### Ongoing Cost (Production)
- Assumption: 40 articles/day from RSS feeds
- Daily: 40 × $0.0002 = **$0.008/day**
- Monthly: **$0.25/month**
- Annual: **$3/year**

**Well within $50/month budget** ✅

---

## 🚨 Risks & Mitigations

### Risk: OpenAI API failures
**Mitigation:** Job queue retry logic (3 attempts with exponential backoff)

### Risk: Cost overrun if RSS volume spikes
**Mitigation:** Daily budget cap already in place ($50/day hard limit)

### Risk: Embedding generation slow (500ms per article)
**Mitigation:** Async job queue, doesn't block RSS fetch

### Risk: Stale articles without embeddings
**Mitigation:** Backfill script can enrich existing articles on-demand

---

## 📎 Related Files

- **RSS Fetch:** `scripts/rss/fetch_feed.js`
- **Clustering:** `scripts/rss/hybrid-clustering.js`
- **Enrichment:** `scripts/job-queue-worker.js` (enrichStory handler)
- **Centroid Tracking:** `scripts/rss/centroid-tracking.js`
- **Merge Detection:** `scripts/rss/periodic-merge.js`

---

**Decision Needed:** Which option should we implement?

**Recommendation:** Option 1 (Article Enrichment Job)
